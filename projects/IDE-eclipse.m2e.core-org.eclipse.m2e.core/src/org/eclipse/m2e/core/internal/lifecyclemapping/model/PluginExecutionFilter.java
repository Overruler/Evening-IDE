/*
 =================== DO NOT EDIT THIS FILE ====================
 Generated by Modello 1.4.1 on 2014-10-24 21:03:25,
 any modifications will be overwritten.
 ==============================================================
 */

package org.eclipse.m2e.core.internal.lifecyclemapping.model;

/**
 * Class PluginExecutionFilter.
 * 
 * @version $Revision$ $Date$
 */
@SuppressWarnings( "all" )
public class PluginExecutionFilter
    implements java.io.Serializable, java.lang.Cloneable
{

      //--------------------------/
     //- Class/Member Variables -/
    //--------------------------/

    /**
     * Field groupId.
     */
    private String groupId;

    /**
     * Field artifactId.
     */
    private String artifactId;

    /**
     * Field versionRange.
     */
    private String versionRange;

    /**
     * Field goals.
     */
    private java.util.Set<String> goals;

    /**
     * Field parameters.
     */
    private java.util.Map parameters;


      //-----------/
     //- Methods -/
    //-----------/

    /**
     * Method addGoal.
     * 
     * @param string
     */
    public void addGoal( String string )
    {
        getGoals().add( string );
    } //-- void addGoal( String )

    /**
     * Method addParameter.
     * 
     * @param key
     * @param value
     */
    public void addParameter( Object key, String value )
    {
        getParameters().put( key, value );
    } //-- void addParameter( Object, String )

    /**
     * Method clone.
     * 
     * @return PluginExecutionFilter
     */
    public PluginExecutionFilter clone()
    {
        try
        {
            PluginExecutionFilter copy = (PluginExecutionFilter) super.clone();

            if ( this.goals != null )
            {
                copy.goals = new java.util.HashSet<String>();
                copy.goals.addAll( this.goals );
            }

            if ( this.parameters != null )
            {
                copy.parameters = new java.util.HashMap();
                copy.parameters.clear();
                copy.parameters.putAll( this.parameters );
            }

            return copy;
        }
        catch ( java.lang.Exception ex )
        {
            throw (java.lang.RuntimeException) new java.lang.UnsupportedOperationException( getClass().getName()
                + " does not support clone()" ).initCause( ex );
        }
    } //-- PluginExecutionFilter clone()

    /**
     * Method equals.
     * 
     * @param other
     * @return boolean
     */
    public boolean equals( Object other )
    {
        if ( this == other )
        {
            return true;
        }

        if ( !( other instanceof PluginExecutionFilter ) )
        {
            return false;
        }

        PluginExecutionFilter that = (PluginExecutionFilter) other;
        boolean result = true;

        result = result && ( getGroupId() == null ? that.getGroupId() == null : getGroupId().equals( that.getGroupId() ) );
        result = result && ( getArtifactId() == null ? that.getArtifactId() == null : getArtifactId().equals( that.getArtifactId() ) );
        result = result && ( getVersionRange() == null ? that.getVersionRange() == null : getVersionRange().equals( that.getVersionRange() ) );
        result = result && ( getGoals() == null ? that.getGoals() == null : getGoals().equals( that.getGoals() ) );

        return result;
    } //-- boolean equals( Object )

    /**
     * Get the artifactId field.
     * 
     * @return String
     */
    public String getArtifactId()
    {
        return this.artifactId;
    } //-- String getArtifactId()

    /**
     * Method getGoals.
     * 
     * @return Set
     */
    public java.util.Set<String> getGoals()
    {
        if ( this.goals == null )
        {
            this.goals = new java.util.HashSet<String>();
        }

        return this.goals;
    } //-- java.util.Set<String> getGoals()

    /**
     * Get the groupId field.
     * 
     * @return String
     */
    public String getGroupId()
    {
        return this.groupId;
    } //-- String getGroupId()

    /**
     * Method getParameters.
     * 
     * @return Map
     */
    public java.util.Map getParameters()
    {
        if ( this.parameters == null )
        {
            this.parameters = new java.util.HashMap();
        }

        return this.parameters;
    } //-- java.util.Map getParameters()

    /**
     * Get the versionRange field.
     * 
     * @return String
     */
    public String getVersionRange()
    {
        return this.versionRange;
    } //-- String getVersionRange()

    /**
     * Method hashCode.
     * 
     * @return int
     */
    public int hashCode()
    {
        int result = 17;

        result = 37 * result + ( groupId != null ? groupId.hashCode() : 0 );
        result = 37 * result + ( artifactId != null ? artifactId.hashCode() : 0 );
        result = 37 * result + ( versionRange != null ? versionRange.hashCode() : 0 );
        result = 37 * result + ( goals != null ? goals.hashCode() : 0 );

        return result;
    } //-- int hashCode()

    /**
     * Method removeGoal.
     * 
     * @param string
     */
    public void removeGoal( String string )
    {
        getGoals().remove( string );
    } //-- void removeGoal( String )

    /**
     * Set the artifactId field.
     * 
     * @param artifactId
     */
    public void setArtifactId( String artifactId )
    {
        this.artifactId = artifactId;
    } //-- void setArtifactId( String )

    /**
     * Set the goals field.
     * 
     * @param goals
     */
    public void setGoals( java.util.Set<String> goals )
    {
        this.goals = goals;
    } //-- void setGoals( java.util.Set )

    /**
     * Set the groupId field.
     * 
     * @param groupId
     */
    public void setGroupId( String groupId )
    {
        this.groupId = groupId;
    } //-- void setGroupId( String )

    /**
     * Set the parameters field.
     * 
     * @param parameters
     */
    public void setParameters( java.util.Map parameters )
    {
        this.parameters = parameters;
    } //-- void setParameters( java.util.Map )

    /**
     * Method toString.
     * 
     * @return String
     */
    public java.lang.String toString()
    {
        StringBuilder buf = new StringBuilder( 128 );

        buf.append( "groupId = '" );
        buf.append( getGroupId() );
        buf.append( "'" );
        buf.append( "\n" ); 
        buf.append( "artifactId = '" );
        buf.append( getArtifactId() );
        buf.append( "'" );
        buf.append( "\n" ); 
        buf.append( "versionRange = '" );
        buf.append( getVersionRange() );
        buf.append( "'" );
        buf.append( "\n" ); 
        buf.append( "goals = '" );
        buf.append( getGoals() );
        buf.append( "'" );

        return buf.toString();
    } //-- java.lang.String toString()

    
  public PluginExecutionFilter() {
  }

  public PluginExecutionFilter(String groupId, String artifactId, String versionRange, java.util.Set<String> goals) {
    this.groupId = groupId;
    this.artifactId = artifactId;
    setVersionRange(versionRange);
    this.goals = goals;
  }
  
  public PluginExecutionFilter(String groupId, String artifactId, String versionRange, String goals) {
    this(groupId, artifactId, versionRange, new java.util.LinkedHashSet<String>(java.util.Arrays.asList(goals.split(",")))); //$NON-NLS-1$;
  }
  
  private transient org.apache.maven.artifact.versioning.VersionRange parsedVersionRange;

  public void setVersionRange(String versionRange) {
    this.versionRange = versionRange;
    try {
      parsedVersionRange = org.apache.maven.artifact.versioning.VersionRange.createFromVersionSpec(versionRange);
    } catch(org.apache.maven.artifact.versioning.InvalidVersionSpecificationException e) {
      throw new IllegalArgumentException("Cannot parse version range: " + versionRange, e);
    }
  }

  private void checkAllFieldsSet() {
    if (groupId==null || artifactId==null || versionRange==null || goals==null || goals.isEmpty() ){
      throw new IllegalArgumentException(
      "Missing parameter for pluginExecutionFilter. " +
      "groupId, artifactId, versionRange and goals must be specificed, but found: "+this);
    }
  }

  /**
   * Returns true if mojoExecution matches this key or false otherwise. This method does not consider mojo execution
   * parameters. 
   */
  public boolean match(org.eclipse.m2e.core.project.configurator.MojoExecutionKey mojoExecution) {
    checkAllFieldsSet();
    if(!getGroupId().equals(mojoExecution.getGroupId()) || !getArtifactId().equals(mojoExecution.getArtifactId())) {
      return false;
    }

    org.apache.maven.artifact.versioning.DefaultArtifactVersion version = new org.apache.maven.artifact.versioning.DefaultArtifactVersion(mojoExecution.getVersion());

    if(parsedVersionRange==null) {
      try {
        parsedVersionRange = org.apache.maven.artifact.versioning.VersionRange.createFromVersionSpec(versionRange);
      } catch(org.apache.maven.artifact.versioning.InvalidVersionSpecificationException e) {
        throw new IllegalArgumentException("Cannot parse version range: " + versionRange, e);
      }
    }

    if(!parsedVersionRange.containsVersion(version)) {
      return false;
    }

    return getGoals().contains(mojoExecution.getGoal());
  }
            
          
}
